[
  {
    "id": 1376,
    "task": {
      "id": 1324,
      "cost": 2,
      "text": "Базовые и производные типы данных. Иерархия определений типов данных и вложенности компонент переменных. Контекстный способ определения типа данных в Си. Абстрактный тип данных. Спецификация typedef.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Тип данных и переменная",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1377,
    "task": {
      "id": 1302,
      "cost": 2,
      "text": "Время жизни и область действия переменных. Классификация. Определение и объявление переменных. Внешние, автоматические и статические переменные. Область действия функций. Внешние и статические функции.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Модульная организация программы",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1378,
    "task": {
      "id": 1346,
      "cost": 2,
      "text": "Статическое связывание. Библиотеки. Заголовочные файлы, их назначение и содержание. Файл проекта в классическом программировании.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Модульное программирование",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1379,
    "task": {
      "id": 1323,
      "cost": 2,
      "text": "Указатель как элемент архитектуры компьютера. Синтаксис указателя в Си. Указатель и ссылка. Передача формальных параметров и результата по значению и по ссылке.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Указатели",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1380,
    "task": {
      "id": 1288,
      "cost": 2,
      "text": "Указатели и массивы. Способы работы через указатель с массивом.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Адресная арифметика",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1381,
    "task": {
      "id": 1345,
      "cost": 2,
      "text": "Динамические переменные и массивы. Операторы и функции управления динамической памятью.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Динамическая память",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1382,
    "task": {
      "id": 1325,
      "cost": 2,
      "text": "Способы формирования массивов указателей - статические, динамические, смешанные. Работа с массивами указателей.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Массивы указателей",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1383,
    "task": {
      "id": 1347,
      "cost": 2,
      "text": "Определение элемента списка. Способы формирования списков. Односвязные списки.   Двусвязные (циклические) списки.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Списки",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1384,
    "task": {
      "id": 1283,
      "cost": 2,
      "text": "Рекурсивная структура данных и функция. Реализация рекурсивных функций, роль стека. Инвариант рекурсивной функции. Особенности разработки рекурсивных алгоритмов. Смысл локальных и глобальных переменных, формальных и фактических параметров в рекурсивной функции. Способы накопления результата.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Рекурсия",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1385,
    "task": {
      "id": 1322,
      "cost": 2,
      "text": "Способы представления деревьев. Полный рекурсивный обход дерева (для всех способов представления).Алгоритмы, основанные на полном рекурсивном обходе дерева.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Деревья",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1386,
    "task": {
      "id": 1284,
      "cost": 2,
      "text": "Его определение в языке и назначение. Указатель на функцию - формальный параметр. Динамическое связывание. Пример - численное интегрирование.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Указатель на функцию",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1387,
    "task": {
      "id": 1343,
      "cost": 2,
      "text": "Двоичный и текстовый файл. Запись. Последовательный и произвольный доступ. Текстовый файл. Позиционирование в текстовом файле. Пример - создание \"закладок\" в файле.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Файл",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1388,
    "task": {
      "id": 1281,
      "cost": 2,
      "text": "Понятие формата. Пример: сохранение и загрузка дерева в последовательный ДФ.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Последовательный двоичный файл",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1389,
    "task": {
      "id": 1349,
      "cost": 2,
      "text": "Понятие записи и ключа. Линейный и двоичный поиск. Трудоемкость алгоритмов сортировки и поиска. Классификация сортировок: выбор, вставка, обмен, подсчет, разделение, слияние.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Сортировка и поиск",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1390,
    "task": {
      "id": 1342,
      "cost": 2,
      "text": "Способы представления деревьев. Полный рекурсивный обход, ветвление. Алгоритмы, основанные на полном рекурсивном обходе дерева. Эффективность алгоритмов на деревьях.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Деревья",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1391,
    "task": {
      "id": 1289,
      "cost": 2,
      "text": "Свойства и методы (функции) класса. Синтаксическое и технологическое определение класса. Технология ООП. Программирование от функции к функции и от класса к классу. \"Эпизодическое\" и \"тотальное\" ООП.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Определение класса и объекта",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1392,
    "task": {
      "id": 1321,
      "cost": 2,
      "text": "Иерархия объектов. Базовый и производный классы. Наследование данных и методов. Наследование как основа программирования \"от класса к классу\". Объектно-ориентированные библиотеки, работа с ними с использованием наследования. Наследование. Способы наследования методов: полное наследование, перекрытие, частичное (условное) наследование. Конструирование объектов вложенных классов.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Наследование",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1393,
    "task": {
      "id": 1341,
      "cost": 2,
      "text": "Назначение закрытых и открытых данных и методов. Дружественность. Конструктор и деструктор. Глобальные, локальные и динамические объекты.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Закрытая и общая части класса",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1394,
    "task": {
      "id": 1287,
      "cost": 2,
      "text": "Виртуальная функция как основа для создания интерфейсов. Абстрактные базовые классы. Виртуальная функция как элемент \"отложенного\" программирования.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Внешний и внутренний полиморфизм",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1395,
    "task": {
      "id": 1285,
      "cost": 2,
      "text": "Параметры шаблонов. Примеры шаблонов структур данных: стек, очередь, список. Требования к объектам - параметрам шаблонов.",
      "taskType": "QUESTION",
      "theme": {
        "id": 7,
        "name": "Шаблон как макроопределение класса",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  },
  {
    "id": 1396,
    "task": {
      "id": 1267,
      "cost": 20,
      "text": "Задачу реализовать в виде функции, получающей все данные через параметры. Все структуры данных - динамические.\nЗамечания по выполняемым операциям. Объединение - результат содержит элементы из двух исходных структур данных (СД), элемент, присутствующий в обеих СД, включается в одном экземпляре. Пересечение - результат содержит элементы, одновременно присутствующие в обеих структурах данных. Разность - результат содержит элементы из первой СД, которые отсутствуют во второй.\nПересечение двух циклических списков.",
      "taskType": "EXERCISE",
      "theme": {
        "id": 7,
        "name": "Двусвязные списки",
        "discipline": {
          "id": 6,
          "name": "Языки программирования"
        }
      }
    }
  }
]